import java.text.SimpleDateFormat

def purgeBranchesOlderThan(days) {

    println("Trying to purge branches that are older than `$days`. Updating remote: `${updateRemote()}`")

    "git config core.sparsecheckout false".execute()

    // fetch on CI
    "git config core.sparsecheckout false".execute()

    // checkout master
    "git checkout master".execute()
    "git pull".execute()

    // get all branches
    def branches = "git branch -r".execute().text.split("\n")

    println("branches $branches")
    for (branch in branches) {
        println("branches $branch")
    }

    println("\nStale Branches (older than $days days)\n")

    // run through all branches
    for (branch in branches) {

        // remove white spaces at the edges
        branch = branch.trim()

        // ignore master and develop
        if (branch.contains("master")) continue
        if (branch.contains("develop")) continue

        // figure out if there are any commits ahead master since x days
        def logs = "git log master..$branch --pretty=oneline --since=${days}.days.ago --stat".execute().text

        // tag and remove branches where there were no commits since x days
        if (logs.isEmpty()) {

            printStatsFor(branch)

            def remote = updateRemote()
            tag(branch, remote)
            close(branch, remote)
        }
    }
}

static def tag(branch, updateRemote) {
    branch = branch.replace("origin/", "")

    // tag
    "git tag stale/$branch".execute().text

    if (!updateRemote) return

    // push to origin
    "git push origin stale/$branch".execute()
}

static def close(branch, updateRemote) {
    branch = branch.replace("origin/", "")

    if (!updateRemote) return

    "git push origin --delete $branch".execute()
}

def days() {
    if (System.hasProperty("days")) {
        return System.getProperty("days")
    } else if (project.hasProperty("days")) {
        return project.getProperty("days")
    } else {
        // everything higher than ~ 1643384300 will cause overflow
        return 1600000000
    }
}

def updateRemote() {
    if (System.hasProperty("updateRemote")) {
        return System.getProperty("updateRemote") == "true"
    } else if (project.hasProperty("updateRemote")) {
        return project.getProperty("updateRemote") == "true"
    } else {
        return false
    }
}

def printStatsFor(branch) {

    // 2022-01-30 14:45:33 +0100
    def dateFormatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss z")

    def lastCommit = "git log master..$branch -1 --format=%ai".execute().text.trim()

    if (lastCommit == "") return

    def commitDate = dateFormatter.parse(lastCommit)
    def duration = groovy.time.TimeCategory.minus(new Date(), commitDate)

    def behind = "git rev-list $branch..master".execute().text.split('\n').size()
    def ahead = "git rev-list master..$branch".execute().text.split('\n').size()

    println("Last commit before $duration | Ahead: $ahead | Behind: $behind | `$branch`")
}

task purge() {
    doLast {
        purgeBranchesOlderThan(days())
    }
}